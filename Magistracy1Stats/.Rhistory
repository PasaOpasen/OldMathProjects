colnames(ms)=c("mean")
rownames(ms)=levels(tb$Year)
library(ggplot2)
df=data.frame(time=as.numeric(levels(tb$Year)),price=ms$mean)
ggplot(df,
aes(time,price))+
geom_point(size=3)+
geom_smooth(method = lm,se=F)+
geom_smooth(method =loess,col="red")
}
#forma=ts(df$price,start = min( df$time),frequency = 1)
#plot(stl(forma, s.window = 21)$time.series,main="")
price1 = c(
40 + p1,43 + p1,40,80,
74,40 + p2,55 + p2,42 + p2,
42,50,40 + p2,43,43,
35 + p1,40 + p1,30,36 + p1,
50,30 + p1,29,45 + p1,
40,42,40,36,
50,30 + p1,24 + p2,
25 + p2,40,32 + p1,
30,20,30,25,32 + p2
)
summary(price1)#минимальные характеристики
t.test(price1)#тест Стьюдента для среднего
vart=sd(price1)/mean(price1)*100
cat("Коэффициент вариации равен",vart,"%\n")
#так как коэффициент вариации < 30%, выборка достаточно однородная
t.test(means[,2],price1)
#Задание 4
library(readxl)
data=data.frame(read_xlsx("РожьВсеГода.xlsx"))
data[,-1]=apply(data[,-1], 2, as.numeric)#перевести в числа все строки
y=t(data[,-1])#транспонирование для удобства
#получить массив лет
ns=rownames(y)
x=sapply(ns, function(s) as.numeric(substr(s,2,nchar(s))))
library(mice)#обработать пустые значения
imp=mice(y,seed=11)
y=complete(imp,action = 1)
df=data.frame(x=x,y=y[,2])#объединить данные в фрейм
print(df[sort(sample(1:nrow(df),13)),])
library(ggplot2)
ggplot(df,aes(x=x,y=y))+
geom_line(col="green")+
geom_point(size=2)+
geom_smooth(method = lm)+
geom_smooth(se=F,col="red")
mt=lm(y~x,df)
summary(mt)
mt=lm(log(y)~x,df)
summary(mt)
mt=lm(log(y)~log(x),df)
summary(mt)
mt=lm(sqrt(y)~x,df)
summary(mt)
mt=lm(log(y)~log(x)+I(log(x)^2),df)
summary(mt)
x=x[!is.na(df$y)]
mt=lm(log(y)~log(x),df)
res=mt$residuals
#скользящее среднее
library(caTools)
k=c(3,5,9)
plot(x,res,type="l",col="grey")
for(i in 1:length(k)){
lines(x,runmean(res,k[i]),col=i,lwd=2)
}
legend("topleft",c(paste("k =", k)),col=1:length(k),bty="n",lwd=2)
library(corrgram)
nn=20
library(corrgram)
nn=20
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)][1:5,1:5])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data[1:5,1:5])
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=20
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=25
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=30
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*5,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=35
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
getOption("repos")
###################################Задание 4
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
pairs(data[,1:7],col=data$CLASS,pch=16)
newdata=as_data_frame(data)%>%group_by(CLASS)%>%
summarise_all(funs(mean))
faces(newdata[,2:8])#рисуем лица
#номер варианта
nv=7
#чтение данных и чистка
library(readxl)
datacrude =data.frame(read_excel("Таблица 1.xlsx")) #считывание таблицы
data=datacrude[5:nrow(datacrude),-1]#удаление лишних строк и столбцов
data=data[-nv,]#удаление строки в соответствиии с номером варианта
colnames(data)=c("Country","Doctors","Deaths","GDP","Costs")#переименование столбцов
data[,2:5]=apply(data[,2:5],2,function(x)scale(as.numeric(x)))#тут переменные из текста преобразуются в числа и стандартизируются
data[,1]=factor(data[,1])#первая переменная из количественной преобразуется в номенативную
###################################Задание 4
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
pairs(data[,1:7],col=data$CLASS,pch=16)
newdata=as_data_frame(data)%>%group_by(CLASS)%>%
summarise_all(funs(mean))
faces(newdata[,2:8])#рисуем лица
library(dplyr)
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
pairs(data[,1:7],col=data$CLASS,pch=16)
newdata=as_data_frame(data)%>%group_by(CLASS)%>%
summarise_all(funs(mean))
faces(newdata[,2:8])#рисуем лица
tmp=numeric()
library(mvnormtest)
for(i in 1:length(levels(data$CLASS))){
tmp[1]=mshapiro.test(t(data[data$CLASS == i, 1:7]))
}
install.packages("mvnormtest")
tmp=numeric()
library(mvnormtest)
for(i in 1:length(levels(data$CLASS))){
tmp[1]=mshapiro.test(t(data[data$CLASS == i, 1:7]))
}
tmp=numeric()
library(mvnormtest)
for(i in 1:length(levels(data$CLASS))){
tmp[1]=mshapiro.test(t(data[data$CLASS == i, 1:7]))
}
View(tmp)
View(data)
tmp=numeric()
library(mvnormtest)
for(i in 1:length(levels(data$CLASS))){
tmp[i]=mshapiro.test(t(data[data$CLASS == i, 1:7])$p.value)
}
tmp=numeric()
library(mvnormtest)
for(i in 1:length(levels(data$CLASS))){
tmp[i]=mshapiro.test(t(data[data$CLASS == i, 1:7]))$p.value
}
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="t")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
print(Err_S)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
print(Err_S)
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
print(Err_S)
print(mahDist)
print(group != classified)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",Err_S[1],'\n')
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",Err_S[1],'\n')
cat("Расстояния Махалонобиса:\n")
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
cat("Ошибка при скользящем контроле:",Err_CV[1],'\n')
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
return()
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",Err_S[1],'\n')
cat("Расстояния Махалонобиса:\n")
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
cat("Ошибка при скользящем контроле:",Err_CV[1],'\n')
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
return(1)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
ldadat$means#групповые средние
(mat=ldadat$scaling)#матрица дискриминантных функций
#matrix(nrow=1,as.numeric(data[65,1:7]))%*%as.matrix(mat)
#plot(ldadat)
#функция для оценки ошибки
misclass <- function(pred, obs) {
tbl <- table(pred, obs)
sum <- colSums(tbl)
dia <- diag(tbl)
msc <- (sum - dia)/sum * 100
m.m <- mean(msc)
cat("Classification table:", "\n")
print(tbl)
cat("Misclassification errors:", "\n")
print(round(msc, 1))
}
misclass(predict(ldadat, data[,1:7])$class, data[,8])
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",1-Err_S[1],'\n')
cat("Расстояния Махалонобиса:\n")
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
cat("Ошибка при скользящем контроле:",Err_CV[1],'\n')
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
ldam <- manova(as.matrix( data[,1:7]) ~ data$CLASS)
summary(ldam, test="Wilks")
return(1)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",1-Err_S[1],'\n')
cat("Расстояния Махалонобиса:\n")
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
cat("Ошибка при скользящем контроле:",Err_CV[1],'\n')
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
ldam <- manova(as.matrix( data[,1:7]) ~ data$CLASS)
print(summary(ldam, test="Wilks"))
return(1)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
library(MASS)
# Функция вывода результатов классификации
Out_CTab <- function(model, group) {
# Таблица неточностей "Факт/Прогноз" по обучающей выборке
classified <- predict(model)$class
t1 <- table(group, classified)
# Точность классификации и расстояние Махалонобиса
Err_S <- mean(group != classified)
mahDist <- dist(model$means %*% model$scaling)
cat("Точность классификации:",1-Err_S[1],'\n')
cat("Расстояния Махалонобиса:\n")
print(mahDist)
# Таблица "Факт/Прогноз" и ошибка при скользящем контроле
t2 <-  table(group, update(model, CV = T)$class -> LDA.cv)
Err_CV <- mean(group != LDA.cv)
cat("Ошибка при скользящем контроле:",Err_CV[1],'\n')
Err_S.MahD <- c(Err_S, mahDist)
Err_CV.N <- c(Err_CV, length(group))
cbind(t1, Err_S.MahD, t2, Err_CV.N)
cat("Результаты многомерного дисперсионного анализа: \n")
ldam <- manova(as.matrix( data[,1:7]) ~ data$CLASS)
print(summary(ldam, test="Wilks"))
return(1)
}
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="moment")
Out_CTab(ldadat,data$CLASS)
