ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1.3,2,3))
}
getimage(3)
#номер варианта
nv=7
#чтение данных и чистка
library(readxl)
datacrude =data.frame(read_excel("Таблица 1.xlsx")) #считывание таблицы
data=datacrude[5:nrow(datacrude),-1]#удаление лишних строк и столбцов
data=data[-nv,]#удаление строки в соответствиии с номером варианта
colnames(data)=c("Country","Doctors","Deaths","GDP","Costs")#переименование столбцов
data[,2:5]=apply(data[,2:5],2,function(x)scale(as.numeric(x)))#тут переменные из текста преобразуются в числа и стандартизируются
data[,1]=factor(data[,1])#первая переменная из количественной преобразуется в номенативную
#####################################Задание 1
d = dist(data[,2:5], method = "euclidean")#матрица расстояний
fit <- hclust(d, method = "ward.D")
plot(fit, labels = data$Country,xlab = "Countries")
plot(fit$height, xlab = "step",ylab="dist",type="b",col="blue",lwd=1,main="Расстояния при объединении кластеров")
mat=fit$merge
resu=list()
countries=as.character(data$Country)
for(i in 1:nrow(mat)){
if(mat[i,1]<0){
a=countries[-mat[i,1]]
}else{
a=as.character(resu[[mat[i,1]]])
}
if(mat[i,2]<0){
b=countries[-mat[i,2]]
}else{
b=as.character(resu[[mat[i,2]]])
}
resu[[i]]=c(a,b)
}
names(resu)=paste("Шаг",1:nrow(mat),"расстояние", fit$height)
print(resu)
####################################Задание 2
it=1:8
sums=sapply(it, function(k) kmeans(data[,2:5], k)$tot.withinss)
plot(it,sums,type = "b",col="red",main = "Суммы внутригрупповых расстояний при разном числе кластеров")
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
#print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#print(summary(aov(Costs~cluster,newdata)))
library(cluster) clusplot(newdata, newdata$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
library(ggplot2)
library(ggpubr)
#здесь создаётся таблица со средними по каждой переменной и каждому классу в том виде, в каком удобней рисовать
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line()+
geom_point(size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1.3,2,3))
}
getimage(3)
####################################Задание 2
it=1:8
sums=sapply(it, function(k) kmeans(data[,2:5], k)$tot.withinss)
plot(it,sums,type = "b",col="red",main = "Суммы внутригрупповых расстояний при разном числе кластеров")
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
#print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#print(summary(aov(Costs~cluster,newdata)))
library(cluster)
clusplot(newdata, newdata$cluster, color=TRUE, shade=TRUE, labels=2, lines=0)
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
library(ggplot2)
library(ggpubr)
#здесь создаётся таблица со средними по каждой переменной и каждому классу в том виде, в каком удобней рисовать
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line()+
geom_point(size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1.3,2,3))
}
getimage(3)
install.packages("factoextra")
unlink('Многомерная статистика_cache', recursive = TRUE)
#номер варианта
nv=7
#чтение данных и чистка
library(readxl)
datacrude =data.frame(read_excel("Таблица 1.xlsx")) #считывание таблицы
data=datacrude[5:nrow(datacrude),-1]#удаление лишних строк и столбцов
data=data[-nv,]#удаление строки в соответствиии с номером варианта
colnames(data)=c("Country","Doctors","Deaths","GDP","Costs")#переименование столбцов
data[,2:5]=apply(data[,2:5],2,function(x)scale(as.numeric(x)))#тут переменные из текста преобразуются в числа и стандартизируются
data[,1]=factor(data[,1])#первая переменная из количественной преобразуется в номенативную
#####################################Задание 1
d = dist(data[,2:5], method = "euclidean")#матрица расстояний
fit <- hclust(d, method = "ward.D")
plot(fit, labels = data$Country,xlab = "Countries")
plot(fit$height, xlab = "step",ylab="dist",type="b",col="blue",lwd=1,main="Расстояния при объединении кластеров")
mat=fit$merge
resu=list()
countries=as.character(data$Country)
for(i in 1:nrow(mat)){
if(mat[i,1]<0){
a=countries[-mat[i,1]]
}else{
a=as.character(resu[[mat[i,1]]])
}
if(mat[i,2]<0){
b=countries[-mat[i,2]]
}else{
b=as.character(resu[[mat[i,2]]])
}
resu[[i]]=c(a,b)
}
names(resu)=paste("Шаг",1:nrow(mat),"расстояние", fit$height)
print(resu)
####################################Задание 2
it=1:8
sums=sapply(it, function(k) kmeans(data[,2:5], k)$tot.withinss)
plot(it,sums,type = "b",col="red",main = "Суммы внутригрупп
овых расстояний при разном числе кластеров")
getimage2=function(k){
fit=kmeans(data[,2:5],k)#строится модель
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
cat("Дисперсионный анализ для каждой переменной: \n")
print(summary(aov(Costs~cluster,newdata)))
print(summary(aov(Deaths~cluster,newdata)))
print(summary(aov(Doctors~cluster,newdata)))
print(summary(aov(GDP~cluster,newdata)))
#рисуются кластеры через главные компоненты
#library(cluster)
#print(clusplot(newdata, newdata$cluster, color=TRUE, shade=TRUE, labels=2, lines=0))
library(factoextra)
print( fviz_cluster(fit, data[, -1], ellipse.type = "norm"))
}
getimage2(3)
getimage2=function(k){
fit=kmeans(data[,2:5],k)#строится модель
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
cat("Дисперсионный анализ для каждой переменной,",k,"кластеров \n")
cat("Затраты \n")
print(summary(aov(Costs~cluster,newdata)))
cat("Смерти \n")
print(summary(aov(Deaths~cluster,newdata)))
cat("Врачи \n")
print(summary(aov(Doctors~cluster,newdata)))
cat("ВВП \n")
print(summary(aov(GDP~cluster,newdata)))
#рисуются кластеры через главные компоненты
#library(cluster)
#print(clusplot(newdata, newdata$cluster, color=TRUE, shade=TRUE, labels=2, lines=0))
library(factoextra)
print( fviz_cluster(fit, data[, -1], ellipse.type = "norm"))
}
getimage2(3)
#Вариант 7
p1 = nchar("Дмитрий")
p2 = nchar("Пасько")
#Задание 1
library(readxl)
library(dplyr)
tab=data.frame(t(read_xlsx("Рожь18век.xlsx")))
names(tab)=sapply( tab[1,], as.character)#поставить правильные названия
tab=tab[-1,]#удалить строку с именами
tab=data.frame(Year=sapply(rownames(tab),as.numeric),tab)
tab=sapply(tab, as.numeric)#факторы перевести в числа
head(as_data_frame(tab),10)
tmptab=tab[,-1]
means=list(rowMeans(tmptab,na.rm = T))
for(i in 1:((ncol(tab)-1)/2)){
means[[i+1]]=rowMeans(tmptab[,c(i,i+1)],na.rm = T)
}
means=sapply(means,function(col)sapply(col, function(row) ifelse(is.nan(row),NA,row)))#Заменить все NaN на NA
means=data.frame(tab[,1],means)
names(means)=c("Год","ПоСтране","Район1","Район2","Район3","Район4","Район5","Район6","Район7","Район8","Район9")
head(means)
library(ggplot2)
p1=  ggplot(means,aes(x=Год))+
geom_line(aes(y=ПоСтране),size=1)
p2=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район1),size=1,col=2)
p3=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район2),size=1,col=3)
p4=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район3),size=1,col=5)
p5=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район4),size=1,col=6)
p6= ggplot(means,aes(x=Год))+
geom_line(aes(y=Район5),size=1,col=7)
p7= ggplot(means,aes(x=Год))+
geom_line(aes(y=Район6),size=1,col=8)
p8=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район7),size=1,col=9)
p9=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район8),size=1,col=10)
p10=  ggplot(means,aes(x=Год))+
geom_line(aes(y=Район9),size=1,col=11)
library(ggpubr)
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,nrow=5,ncol=2)
if(FALSE){
library(readxl)
tab=data.frame(read_xlsx("Псевдоцены.xlsx"))
colnames(tab)=c("Price","Year","City","Distrinct")
tab$Year=factor(tab$Year)
tab$City=factor(tab$City)
tab$Distrinct=factor(tab$Distrinct)
library(dplyr)
tib=data_frame(tab)[[1]]
# по городам
tb=tib%>%select(Price,Year,City)%>%group_by(Year,City)%>%
summarise(mean=mean(Price))
ms=matrix(tb$mean,nrow=length(levels(tb$Year)))
ms= data.frame(ms)
colnames(ms)=levels(tb$City)
rownames(ms)=levels(tb$Year)
# по районам
tb=tib%>%select(Price,Year,Distrinct)%>%group_by(Year,Distrinct)%>%
summarise(mean=mean(Price))
ms=matrix(tb$mean,nrow=length(levels(tb$Year)))
ms= data.frame(ms)
colnames(ms)=levels(tb$Distrinct)
rownames(ms)=levels(tb$Year)
# по стране
tb=tib%>%select(Price,Year)%>%group_by(Year)%>%
summarise(mean=mean(Price))
ms=matrix(tb$mean,nrow=length(levels(tb$Year)))
ms= data.frame(ms)
colnames(ms)=c("mean")
rownames(ms)=levels(tb$Year)
library(ggplot2)
df=data.frame(time=as.numeric(levels(tb$Year)),price=ms$mean)
ggplot(df,
aes(time,price))+
geom_point(size=3)+
geom_smooth(method = lm,se=F)+
geom_smooth(method =loess,col="red")
}
#forma=ts(df$price,start = min( df$time),frequency = 1)
#plot(stl(forma, s.window = 21)$time.series,main="")
price1 = c(
40 + p1,43 + p1,40,80,
74,40 + p2,55 + p2,42 + p2,
42,50,40 + p2,43,43,
35 + p1,40 + p1,30,36 + p1,
50,30 + p1,29,45 + p1,
40,42,40,36,
50,30 + p1,24 + p2,
25 + p2,40,32 + p1,
30,20,30,25,32 + p2
)
summary(price1)#минимальные характеристики
t.test(price1)#тест Стьюдента для среднего
vart=sd(price1)/mean(price1)*100
cat("Коэффициент вариации равен",vart,"%\n")
#так как коэффициент вариации < 30%, выборка достаточно однородная
t.test(means[,2],price1)
#Задание 4
library(readxl)
data=data.frame(read_xlsx("РожьВсеГода.xlsx"))
data[,-1]=apply(data[,-1], 2, as.numeric)#перевести в числа все строки
y=t(data[,-1])#транспонирование для удобства
#получить массив лет
ns=rownames(y)
x=sapply(ns, function(s) as.numeric(substr(s,2,nchar(s))))
library(mice)#обработать пустые значения
imp=mice(y,seed=11)
y=complete(imp,action = 1)
df=data.frame(x=x,y=y[,2])#объединить данные в фрейм
print(df[sort(sample(1:nrow(df),13)),])
library(ggplot2)
ggplot(df,aes(x=x,y=y))+
geom_line(col="green")+
geom_point(size=2)+
geom_smooth(method = lm)+
geom_smooth(se=F,col="red")
mt=lm(y~x,df)
summary(mt)
mt=lm(log(y)~x,df)
summary(mt)
mt=lm(log(y)~log(x),df)
summary(mt)
mt=lm(sqrt(y)~x,df)
summary(mt)
mt=lm(log(y)~log(x)+I(log(x)^2),df)
summary(mt)
x=x[!is.na(df$y)]
mt=lm(log(y)~log(x),df)
res=mt$residuals
#скользящее среднее
library(caTools)
k=c(3,5,9)
plot(x,res,type="l",col="grey")
for(i in 1:length(k)){
lines(x,runmean(res,k[i]),col=i,lwd=2)
}
legend("topleft",c(paste("k =", k)),col=1:length(k),bty="n",lwd=2)
library(corrgram)
nn=20
library(corrgram)
nn=20
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)][1:5,1:5])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data[1:5,1:5])
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=20
for(i in seq(length(x)-60,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=25
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=30
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*5,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=35
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
library(corrgram)
nn=15
for(i in seq(length(x)-nn*3,length(x)-nn,nn)){
tmp=i:(i+nn-1)
cat("Times:",x[tmp],"\n")
data=y[tmp,]#транспонирование, чтобы строки стали переменными
cormatrix=cor(data)
lower=abs(cormatrix[lower.tri(cormatrix)])
cat("Статистика по треугольнику корреляционной матрицы \n")
print(summary(lower[lower!=0]))
corrgram(cormatrix,order=FALSE, lower.panel=panel.shade,
upper.panel=panel.pie)
}
