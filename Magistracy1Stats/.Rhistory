deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
####################################Задание 2
it=1:8
sums=sapply(it, function(k) kmeans(data[,2:5], k)$tot.withinss)
plot(it,sums,type = "b",col="red",main = "Суммы внутригрупповых расстояний при разном числе кластеров")
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
cs=c("red","green","blue","black","yellow")
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
#rg=range(means[-1])*1.2
#plot(as.numeric(means[1,2:5]),type="b",
#     col=cs[1],ylim = rg,ylab = "values of means")
#for(i in 2:k){
#  lines(as.numeric(means[i,2:5]),type="b",col=cs[i])
#}
library(ggplot2)
library(ggpubr)
tmpdata=data.frame(x=1:4,means=means[1,2:5],cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=means[i,2:5],cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line(col=cs[1])+
geom_point(col=cs[1],size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
cs=c("red","green","blue","black","yellow")
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
#rg=range(means[-1])*1.2
#plot(as.numeric(means[1,2:5]),type="b",
#     col=cs[1],ylim = rg,ylab = "values of means")
#for(i in 2:k){
#  lines(as.numeric(means[i,2:5]),type="b",col=cs[i])
#}
library(ggplot2)
library(ggpubr)
tmpdata=data.frame(x=1:4,means=as.vector(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.vector(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line(col=cs[1])+
geom_point(col=cs[1],size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
cs=c("red","green","blue","black","yellow")
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
#rg=range(means[-1])*1.2
#plot(as.numeric(means[1,2:5]),type="b",
#     col=cs[1],ylim = rg,ylab = "values of means")
#for(i in 2:k){
#  lines(as.numeric(means[i,2:5]),type="b",col=cs[i])
#}
library(ggplot2)
library(ggpubr)
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line(col=cs[1])+
geom_point(col=cs[1],size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
cs=c("red","green","blue","black","yellow")
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
#rg=range(means[-1])*1.2
#plot(as.numeric(means[1,2:5]),type="b",
#     col=cs[1],ylim = rg,ylab = "values of means")
#for(i in 2:k){
#  lines(as.numeric(means[i,2:5]),type="b",col=cs[i])
#}
library(ggplot2)
library(ggpubr)
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line()+
geom_point(size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
library(ggplot2)
library(ggpubr)
#здесь создаётся таблица со средними по каждой переменной и каждому классу в том виде, в каком удобней рисовать
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line()+
geom_point(size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1,2,3))
}
getimage(2)
#функция, проводящая некоторый анализ и строящая графики для заданного числа кластеров
getimage=function(k){
fit=kmeans(data[,2:5],k)#строится модель
cat("Внутригрупповые суммы:",fit$withinss,"\n")#внутригрупповые суммы
cat("Общая сумма:", fit$betweenss,"\n")
cat("Матрица расстояний:\n")
print(dist(fit$centers))#матрица расстояний
#Добавляем кластер к фрейму данных
library(dplyr)
newdata=as_data_frame(data)%>%mutate(cluster=factor(fit$cluster))
#агрегирование данных по группам
means=newdata[,2:6]%>%group_by(cluster)%>%summarise(
meanCosts=mean(Costs),sdCosts=sd(Costs),
meanDoctors=mean(Doctors),sdDoctors=sd(Doctors),
meanGDP=mean(GDP),sdGDP=sd(GDP),
meanDeaths=mean(Deaths),sdDeaths=sd(Deaths)
)
print(means)
means=means[,c(1,2,4,6,8)]#берётся сабсет только из значений для средних
lbs=c("cluster1","cluster2","cluster3","cluster4","cluster5")
library(ggplot2)
library(ggpubr)
#здесь создаётся таблица со средними по каждой переменной и каждому классу в том виде, в каком удобней рисовать
tmpdata=data.frame(x=1:4,means=as.numeric(means[1,2:5]),cluster=rep(lbs[1],4))
for(i in 2:k){
tmpdata=rbind(tmpdata,data.frame(x=1:4,means=as.numeric(means[i,2:5]),cluster=rep(lbs[i],4)))
}
tmpdata$cluster=factor(tmpdata$cluster)
print(tmpdata)
ppp=ggplot(tmpdata,aes(x=x,y=means,col=cluster))+
geom_line()+
geom_point(size=4)
pl1=ggplot(newdata, aes(x=Doctors, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl2=ggplot(newdata, aes(x=GDP, y=Costs, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl3=ggplot(newdata, aes(x=GDP, y=Deaths, col = cluster))+
geom_point(size = 3)+
theme_bw()
pl4=ggplot(newdata, aes(x=GDP, y=Doctors, col = cluster))+
geom_point(size = 3)+
theme_bw()
costs = ggplot(newdata, aes(x=cluster, y=Costs))+
geom_boxplot()+
theme_bw()
deaths = ggplot(newdata, aes(x=cluster, y=Deaths))+
geom_boxplot()+
theme_bw()
doctors = ggplot(newdata, aes(x=cluster, y=Doctors))+
geom_boxplot()+
theme_bw()
gdp = ggplot(newdata, aes(x=cluster, y=GDP))+
geom_boxplot()+
theme_bw()
p1 <- ggarrange(pl1, pl2,pl3,pl4,
ncol = 2, nrow = 2)
p2 <- ggarrange(costs, deaths, doctors, gdp,
ncol = 2, nrow = 2)
ggarrange(ppp,p1, p2, ncol = 1, nrow = 3,heights=c(1.3,2,3))
}
getimage(3)
cache=TRUE
datacrude =data.frame(read_excel("Приложение 1.xlsx"))
data=datacrude[,-c(1)]
data=data[,-c(1,2,16,17)]
library(corrplot)
corrplot(cor(data))
library(psych)
principal(data[,-1],nfactors = 8,rotate = "none")#Создание модели
fa.parallel(data[,-1],fa="pc",show.legend = T,main="Диаграмма каменистой осыпи с параллельным анализом")
#варимакс с нормализацией
(vm=principal(apply(data[,-1],2,scale),nfactors = 6,rotate = "varimax"))
#коэффициенты
round(unclass(vm$weights),2)
vm$scores
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="t")
ldadat$means#групповые средние
(mat=ldadat$scaling)#матрица дискриминантных функций
###################################Задание 4
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
library(MASS)
#линейный дискриминантный анализ
ldadat <- lda(CLASS~.,data,method="t")
View(ldadat)
#то же, что и раньше, только методом randomForest
library(randomForest)
rf <- randomForest(data[,8] ~ ., data=data[,1:7])
rfp <- predict(rf, data[,1:7])
table(rfp, data[,8])
MDSplot(randomForest(data[,-8]), data[,8])
misclass(rfp, data[,8])
library(MASS)
misclass(rfp, data[,8])
#функция для оценки ошибки
misclass <- function(pred, obs) {
tbl <- table(pred, obs)
sum <- colSums(tbl)
dia <- diag(tbl)
msc <- (sum - dia)/sum * 100
m.m <- mean(msc)
cat("Classification table:", "\n")
print(tbl)
cat("Misclassification errors:", "\n")
print(round(msc, 1))
}
misclass(predict(ldadat, data[,1:7])$class, data[,8])
#дерево классификации
library(tree)
datatree <- tree(data[,8] ~ ., data[,-8])
plot(datatree)
text(datatree)
#то же, что и раньше, только методом randomForest
library(randomForest)
rf <- randomForest(data[,8] ~ ., data=data[,1:7])
rfp <- predict(rf, data[,1:7])
table(rfp, data[,8])
MDSplot(randomForest(data[,-8]), data[,8])
misclass(rfp, data[,8])
###################################Задание 3
datacrude =data.frame(read_excel("Приложение 1.xlsx"))
data=datacrude[,-c(1)]
data=data[,-c(1,2,16,17)]
library(corrplot)
corrplot(cor(data))
library(psych)
principal(data[,-1],nfactors = 8,rotate = "none")#Создание модели
fa.parallel(data[,-1],fa="pc",show.legend = T,main="Диаграмма каменистой осыпи с параллельным анализом")
#варимакс с нормализацией
(vm=principal(apply(data[,-1],2,scale),nfactors = 6,rotate = "varimax"))
#коэффициенты
round(unclass(vm$weights),2)
#номер варианта
nv=7
#чтение данных и чистка
library(readxl)
###################################Задание 3
datacrude =data.frame(read_excel("Приложение 1.xlsx"))
data=datacrude[,-c(1)]
data=data[,-c(1,2,16,17)]
library(corrplot)
corrplot(cor(data))
library(psych)
principal(data[,-1],nfactors = 8,rotate = "none")#Создание модели
fa.parallel(data[,-1],fa="pc",show.legend = T,main="Диаграмма каменистой осыпи с параллельным анализом")
#варимакс с нормализацией
(vm=principal(apply(data[,-1],2,scale),nfactors = 6,rotate = "varimax"))
#коэффициенты
round(unclass(vm$weights),2)
cor(vm$scores)
