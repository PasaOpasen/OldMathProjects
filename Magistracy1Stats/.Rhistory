}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:4){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
###################################Задание 4
data =data.frame(read_excel("Приложение 2.xlsx"))
data$CLASS=factor(data$CLASS)
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
predict(ldadat, tt[,1:7])$class
levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
predict(ldadat, tt[,1:7])$class
levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
distance(ldadat$means,cov.mat,as.numeric(tt[,-8]))
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
View(cov.mat)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
predict(ldadat, tt[,1:7])$class
distance(ldadat$means,cov.mat,as.numeric(tt[,-8]))
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
cov.mat=covinv(data)
data[data$CLASS==1,1:7] %>% as.matrix() %>% cov()
s=data[data$CLASS==1,1:7] %>% as.matrix() %>% cov()
solve(s)
solve(s)%*%s
s=data[data$CLASS==2,1:7] %>% as.matrix() %>% cov()
solve(s)
s=data[data$CLASS==3,1:7] %>% as.matrix() %>% cov()
solve(s)
s=data[data$CLASS==4,1:7] %>% as.matrix() %>% cov()
solve(s)
s=data[data$CLASS==5,1:7] %>% as.matrix() %>% cov()
solve(s)
s
det(s)
data[data$CLASS==5,1:7] %>% as.matrix() %>% cor()
#матрицы, обратные матрицам ковариации для каждого класса
covinv=function(df){
res=list()
for(i in 1:length(levels(df$CLASS)))
res[[i]]=tryCatch(df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve,Inf)
#res[[i]]=df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve
res
}
covinv(data)
tryCatch(df[df$CLASS==2,1:7] %>% as.matrix() %>% cov() %>% solve,NA)
tryCatch({df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve},error={NA})
tryCatch({df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
tryCatch({df[df$CLASS==2,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
tryCatch({data[data$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
tryCatch({data[data$CLASS==2,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
tryCatch({data[data$CLASS==5,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
#матрицы, обратные матрицам ковариации для каждого класса
covinv=function(df){
res=list()
for(i in 1:length(levels(df$CLASS)))
res[[i]]= tryCatch({df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
#res[[i]]=df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve
res
}
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
#матрицы, обратные матрицам ковариации для каждого класса
covinv=function(df){
res=list()
for(i in 1:length(levels(df$CLASS)))
res[[i]]= tryCatch({df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve},error=function(r) NA)
#res[[i]]=df[df$CLASS==i,1:7] %>% as.matrix() %>% cov() %>% solve
res
}
#расстояния Махаланобиса от элемента до каждого из классов
distance=function(means,covs, elem){
res=c()
for(i in 1:nrow(means)){
vec=(means[i,]-elem)
res[i]=(vec%*%covs[[i]])%*%vec
}
return(sqrt(res))
}
#поиск номера элемента в датафрейме
find.number=function(df,elem){
sm=0
i=0
len=length(elem)
while (sm!=len) {
i=i+1
v=ifelse(df[i,]==elem,T,F)
sm=sum(v)
}
return(i)
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
if(is.na(cov.mat[[cls]])){
distances[i]=NA
}else{
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
View(st)
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
if(is.na(cov.mat[[cls]])){
distances[i]=NA
}else{
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
}
distances=sqrt(distances)
number.of.max.distance=which.max(distances)
#расстояния Махаланобиса от элемента до каждого из классов
distance=function(means,covs, elem){
res=c()
for(i in 1:nrow(means)){
vec=(means[i,]-elem)
res[i]=(vec%*%covs[[i]])%*%vec
}
return(sqrt(res))
}
#поиск номера элемента в датафрейме
find.number=function(df,elem){
sm=0
i=0
len=length(elem)
while (sm!=len) {
i=i+1
v=ifelse(df[i,]==elem,T,F)
sm=sum(v)
}
return(i)
}
acc=0#точность
#while (!near(acc,1))
for(k in 1:40){
ldadat <- lda(CLASS~.,data,method="moment")
means=ldadat$means
cov.mat=covinv(data)
#для всех неправильно найденных найти расстояния до кластеров, отнесённых экспертами
prclass=predict(ldadat, data[,1:7])$class
st=data[data$CLASS!=prclass,]
acc=1-nrow(st)/nrow(data)
cat("Точность классификации:",acc,'\n')
if(nrow(st)==1){
number.of.max.distance=1
}else{
distances=c()
for(i in 1:nrow(st)){
cls=as.numeric(st[i,8])
vec=(means[cls,]-as.numeric(st[i,1:7]))
if(is.na(cov.mat[[cls]])){
distances[i]=NA
}else{
distances[i]=(vec%*%cov.mat[[cls]])%*%vec
}
}
distances=sqrt(distances)
#номер элемента (в таблице неверно отнесённых) с максимальным расстоянием для своего кластера
number.of.max.distance=which.max(distances)
}
tt=st[number.of.max.distance,]#сам элемент
cat("Неправильно отнесённый элемент с максимальным расстоянием (",max(distances,na.rm = T),")\n")
#номер того же элемента, но в исходном фрейме
number.of.max.distance.new=find.number(data,tt)
print(data[number.of.max.distance.new,])
#сделать замену на кластер с минимальным расстоянием
data[number.of.max.distance.new,8]=predict(ldadat, tt[,1:7])$class#levels(data$CLASS)[which.min(distance(ldadat$means,cov.mat,as.numeric(tt[,-8])))]
cat("Заменяется на\n")
print(data[number.of.max.distance.new,])
}
ldadat$means#групповые средние
(mat=ldadat$scaling)#матрица дискриминантных функций
plot(ldadat)
pairs(data[,1:7],col=data$CLASS,pch=16)
Out_CTab(ldadat,data$CLASS)
#функция для оценки ошибки
misclass <- function(pred, obs) {
tbl <- table(pred, obs)
sum <- colSums(tbl)
dia <- diag(tbl)
msc <- (sum - dia)/sum * 100
m.m <- mean(msc)
cat("Classification table:", "\n")
print(tbl)
cat("Misclassification errors:", "\n")
print(round(msc, 1))
}
misclass(predict(ldadat, data[,1:7])$class, data[,8])
